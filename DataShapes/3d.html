<!DOCTYPE html>
<!-- Author : Shaiyon Hariri  -->
<!-- https://shaiyon.com  -->
<html>
<head>
    <script src="three.min.js"></script>
    <!-- Camera Controls  -->
    <script src="orbitControls.js"></script>
    <script src="https://d3js.org/d3.v5.min.js" charset="utf-8"></script>
    <!-- Tooltip functions -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.19/lodash.min.js"></script>
    <link rel="stylesheet" href="title3.css" type="text/css">
</head>
<body>
    <div id="info">3D Knowledge Map</div>
    <div id="hideMe">Double click to stop/start rotation, color represents frequency</div>
    <script>
        // Load in data (asynchronously)
        d3.csv("demo3.csv", function (data) {
            return {
                label: +data.category,
                description: data.description,
                frequency: +data.systemMatchCounter,
                radius: +Math.round(data.influenceDistance),
                name: data.name,
                x: +data.x,
                y: +data.y,
                z: +data.z
            };
        }).then(function(data_points) {
    
        // Scene
        var scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        // Camera
        var width = window.innerWidth;
        var height = window.innerHeight;
        var camera = new THREE.PerspectiveCamera(40, width/height, 0.1, 1000 );
        camera.position.z = 35;

        // Renderer
        var renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(width, height);

        // Camera Controls
        var controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.autoRotate = true;

        document.body.appendChild(renderer.domElement);

        // Event Listeners
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        })
        window.addEventListener('mousemove', onMouseMove, false);
        window.addEventListener('mouseleave', onMouseLeave, false);
        window.addEventListener('dblclick', () => { controls.autoRotate = !controls.autoRotate; });
        window.addEventListener('touchend', touch, false);

        // Light
        var light = new THREE.DirectionalLight(0xffffff);
        light.position.set(10, 10, 10);
        scene.add(light);

        var light = new THREE.DirectionalLight(0xffffff);
        light.position.set(-10, -10, -10);
        scene.add(light);

        var light = new THREE.AmbientLight(0x222222);
        scene.add(light);
        
        // Knowledge Element Color
        let color_array = [
            "rgb(255,0, 0)",
            "rgb(0, 255, 0)",
            "rgb(0, 0, 255)"
        ]
        // Lighten or darken colors
        const RGB_Linear_Shade=(p,c)=>{
            var i=parseInt,r=Math.round,[a,b,c,d]=c.split(","),P=p<0,t=P?0:255*p,P=P?1+p:1-p;
            return"rgb"+(d?"a(":"(")+r(i(a[3]=="a"?a.slice(5):a.slice(4))*P+t)+","+r(i(b)*P+t)+","+r(i(c)*P+t)+(d?","+d:")");
        }
        var frequencies = data_points.map(value => value.frequency);
        // Sort ascending
        frequencies.sort(function(a, b){return a-b});
        // Returns the percentile of the given value in a sorted numeric array.
        function percentRank(array, n) {
            var L = 0;
            var S = 0;
            var N = array.length
            for (var i = 0; i < array.length; i++) {
                if (array[i] < n) {
                    L += 1
                } else if (array[i] === n) {
                    S += 1
                } else {
                }
            }
            var pct = (L + (0.5 * S)) / N
            return pct;
        }
        
        // Add datapoints to plot
        var scatterPlot = new THREE.Object3D();
        for (var i=0; i<data_points.length; i++) {
            var geometry = new THREE.SphereBufferGeometry( data_points[i].radius/275, 20, 20);
            // Scale percentile from [0, 0.8] to prevent super dark colors
            var percentile = percentRank(frequencies, data_points[i].frequency)*0.8;
            var thisColor = RGB_Linear_Shade(-percentile, color_array[data_points[i].label]);
            
            var material = new THREE.MeshLambertMaterial( {color: thisColor } );
            var sphere = new THREE.Mesh( geometry, material );
            sphere.userData.id = i;
            sphere.position.set(data_points[i].x, data_points[i].y, data_points[i].z);
            scatterPlot.add(sphere);
        }

        scene.add(scatterPlot);

        var render = function() {
            requestAnimationFrame(render);
        
        controls.update();
        renderer.render(scene, camera);
        }
        render();
        
        // Double Touch Detection
        var latestTouch;
        function touch() {
            var now = new Date().getTime();
            var timesince = now - latestTouch;
            if((timesince > 300) && (timesince < 1000)) {
                controls.autoRotate = !controls.autoRotate;
            } 
            latestTouch = new Date().getTime();
        }

        // Hover interaction
        var mouseRay = new THREE.Vector3();
        var raycaster = new THREE.Raycaster();

        // mouseMove optimization (checks every x-ms)
        var mouseMoveTimer = null;
        function onMouseMove(event) {
            if (mouseMoveTimer) {
                window.clearTimeout(mouseMoveTimer);
            }
            mouseMoveTimer = window.setTimeout(delayedMouseMove(event), 100);
        }
        function delayedMouseMove(event) {
            mouseRay.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
            mouseRay.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
            mouseRay.z = 1;
            let mouse = [event.clientX, event.clientY];
            raycaster.setFromCamera(mouseRay, camera);
            let intersects = raycaster.intersectObjects(scene.children, true);
            if (intersects[0]) {
                let sorted_intersects = sortIntersectsByDistanceToRay(intersects);
                let intersect = sorted_intersects[0];
                let index = intersect.object.userData.id;
                let datum = data_points[index];
                if (datum) {
                    highlightPoint(datum);
                    showTooltip(mouse, datum)
                }
            } else {
                removeHighlights();
                hideTooltip();
            }
        }

        function sortIntersectsByDistanceToRay(intersects) {
            return _.sortBy(intersects, "distanceToRay");
        }


        // Mouse hover interaction
        hoverContainer = new THREE.Object3D();
        scene.add(hoverContainer);
        function highlightPoint(datum) {
            removeHighlights()
            
            var geometry = new THREE.SphereBufferGeometry( datum.radius/225, 20, 20);
            var material = new THREE.MeshLambertMaterial( {color: color_array[datum.label] } );
            var sphere = new THREE.Mesh( geometry, material );
            sphere.position.set(datum.x, datum.y, datum.z);

            hoverContainer.add(sphere);
        }
        function removeHighlights() {
            hoverContainer.remove(...hoverContainer.children);
        }
        function onMouseLeave() {
            removeHighlights()
        }


        // Initial tooltip state
        let tooltip_state = { display: "none" }
        let tooltip_template = document.createRange().createContextualFragment(`<div id="tooltip" style="border: 1px solid #000000; display: none; position: absolute; pointer-events: none; font-family: Raleway, Arial, Helvetica, sans-serif; font-size: 13px; width: 120px; text-align: center; line-height: 1; padding: 6px; background: white;">
        <div id="point_tip" style="padding: 4px; margin-bottom: 4px;"></div>
        <div id="group_tip" style="padding: 4px;"></div>
        </div>`);
        document.body.append(tooltip_template);

        let $tooltip = document.querySelector('#tooltip');
        let $point_tip = document.querySelector('#point_tip');
        let $group_tip = document.querySelector('#group_tip');

        function updateTooltip() {
            $tooltip.style.display = tooltip_state.display;
            $tooltip.style.left = tooltip_state.left + 'px';
            $tooltip.style.top = tooltip_state.top + 'px';
            $point_tip.innerText = tooltip_state.name;
            $point_tip.style.background = color_array[tooltip_state.label];
            $group_tip.innerText = `DataShape ${tooltip_state.description}
                \nInfluence Distance: ${tooltip_state.radius}
                \nFrequency: ${tooltip_state.frequency}`;
        }
        function showTooltip(mouse, datum) {
            let tooltip_width = 120;
            let x_offset = -tooltip_width / 2;
            let y_offset = 30;
            tooltip_state.display = "block";
            tooltip_state.left = mouse[0] + x_offset;
            tooltip_state.top = mouse[1] + y_offset;
            tooltip_state.name = datum.name;
            tooltip_state.label = datum.label;
            tooltip_state.description = datum.description;
            tooltip_state.radius = datum.radius;
            tooltip_state.frequency = datum.frequency;
            updateTooltip();
        }
        function hideTooltip() {
            tooltip_state.display = "none";
            updateTooltip();
        }
            
        //End d3.csv
        })

    </script>
</body>    
</html>