<!DOCTYPE html>
<!-- Author : Shaiyon Hariri  -->
<!-- https://shaiyon.com  -->
<html>
<head>
    <script src="three.min.js"></script>
    <script src="https://d3js.org/d3.v5.min.js" charset="utf-8"></script>
    <link rel="stylesheet" href="title3.css" type="text/css">
</head>
<body>
    <div id="info">3D Knowledge Map</div>
    <script>
        // Load in data (asynchronously)
        d3.csv("demo3.csv", function (data) {
            return {
                label: +data.category,
                description: data.description,
                frequency: +data.systemMatchCounter,
                radius: +Math.round(data.influenceDistance),
                name: data.name,
                x: +data.x,
                y: +data.y,
                z: +data.z
            };
        }).then(function(data_points) {

        var scatterPlot = new THREE.Object3D();
        var scene = new THREE.Scene();

        var renderer = new THREE.WebGLRenderer({antialias: true});
        var w = document.body.clientWidth;
        var h = document.body.clientHeight;
        renderer.setSize(w, h);
        document.body.appendChild(renderer.domElement);

        // background color
        renderer.setClearColor(new THREE.Color(0xffffff));

        var camera = new THREE.PerspectiveCamera( 45, w/h, 1, 10000 );
        camera.position.z = 200;
        camera.position.x = -100;
        camera.position.y = 100;
        
        var scene = new THREE.Scene();

        var scatterPlot = new THREE.Object3D();
        scene.add(scatterPlot);

        scatterPlot.rotation.y = 0.5;
        
        function v(x,y,z){ return new THREE.Vector3(x,y,z); }

        // Extract coordinates from data points
        // var coordinates = (({ x, y, z }) => ({ x, y, z }))(data_points);
        
        // Limits of graph
        var xExent = d3.extent(data_points, function (d) {return d.x; }),
            yExent = d3.extent(data_points, function (d) {return d.y; }),
            zExent = d3.extent(data_points, function (d) {return d.z; });
        var vpts = {
            xMax: xExent[1],
            xCen: (xExent[1] + xExent[0]) / 2,
            xMin: xExent[0],
            yMax: yExent[1],
            yCen: (yExent[1] + yExent[0]) / 2,
            yMin: yExent[0],
            zMax: zExent[1],
            zCen: (zExent[1] + zExent[0]) / 2,
            zMin: zExent[0]
        }
        var xScale = d3.scaleLinear()
                    .domain(xExent)
                    .range([-50,50]);
        var yScale = d3.scaleLinear()
                    .domain(yExent)
                    .range([-50,50]);                  
        var zScale = d3.scaleLinear()
                    .domain(zExent)
                    .range([-50,50]);
        
        // Lines in plot
        var lineGeo = new THREE.Geometry();
        lineGeo.vertices.push(
            v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zMin)), v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zMin)),
            v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zMin)), v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zMin)),
            v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zMax)), v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zMax)),
            v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zMax)), v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zMax)),

            v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zMin)), v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zMin)),
            v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zMin)), v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zMin)),
            v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zMax)), v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zMax)),
            v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zMax)), v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zMax)),

            v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zMin)), v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zMax)),
            v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zMin)), v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zMax)),
            v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zMin)), v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zMax)),
            v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zMin)), v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zMax)),
        );
        var lineMat = new THREE.LineBasicMaterial({color: 0x808080, linewidth: 1});
        var line = new THREE.Line(lineGeo, lineMat);
        line.type = THREE.Lines;
        scatterPlot.add(line);

        var colorList = [ 
            "#1f78b4",
            "#33a02c",
            "#e31a1c",
            "#fdbf6f",
            "#ff7f00",
            "#b0e0e6",
            "#cab2d6",
            "#ffff99",
            "#d3d3d3"
        ];
        
        // Add csv data to scatterplot
        var pointGeo = new THREE.Geometry();
        for (var i=0; i < data_points.length; i++) {
            var x = xScale(data_points[i].x);
            var y = yScale(data_points[i].y);
            var z = zScale(data_points[i].z);
            
            pointGeo.vertices.push(new THREE.Vector3(x, y, z));
            pointGeo.colors.push(new THREE.Color(colorList[data_points[i].label]));
        }

        var mat = new THREE.PointsMaterial({ vertexColors: true, size: 15 });
        var points = new THREE.Points(pointGeo, mat);
        scatterPlot.add(points);
        scene.add(scatterPlot);

        renderer.render(scene, camera);
        var paused = false;
        var last = new Date().getTime();
        var down = false;
        var sx = 0, sy = 0;

        window.onmousedown = function (ev) {
            down = true; sx = ev.clientX; sy = ev.clientY;
        };
        window.onmouseup = function() { 
            down = false; 
        };
        window.onmousemove = function(ev) {
            if (down) {
            var dx = ev.clientX - sx;
            var dy = ev.clientY - sy;
            scatterPlot.rotation.y += dx*0.01;
            camera.position.y += dy;
            sx += dx;
            sy += dy;
            }
        }
        var animating = false;
        window.ondblclick = function() { animating = !animating; };
        function animate(t) {
            if (!paused) {
            last = t;
            if (animating) {
                var v = pointGeo.vertices;
                for (var i=0; i<v.length; i++) {
                var u = v[i];
                u.angle += u.speed * 0.01;
                u.position.x = Math.cos(u.angle)*u.radius;
                u.position.z = Math.sin(u.angle)*u.radius;
                }
                pointGeo.__dirtyVertices = true;
            }
            renderer.clear();
            camera.lookAt(scene.position);
            renderer.render(scene, camera);
            }
            window.requestAnimationFrame(animate, renderer.domElement);
        }
        animate(new Date().getTime());
        onmessage = function(ev) {
            paused = (ev.data == 'pause');
        };

        // end d3 csv
        })
    </script>
</body>    
</html>