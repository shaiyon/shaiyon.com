<!DOCTYPE html>
<!-- Author : Shaiyon Hariri  -->
<!-- https://shaiyon.com  -->
<html>
<head>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/d3.v5.min.js"></script>
    <!-- Tooltip functions -->
    <script src="js/lodash.core.js"></script>
    <link rel="stylesheet" href="style.css" type="text/css">
</head>
<body>
    <div id="info">Skyscraper Knowledge Map</div>
    <div id="hideMe">Left click to pan, right click to rotate</div>
    <script>
        // Load in data (asynchronously)
        d3.csv("demo2.csv", function (data) {
            return {
                name: data.name,
                description: data.description,
                label: +data.category,
                radius: +Math.round(data.influenceDistance),
                pct: +data.pct,
                x: +data.x*3,
                y: +data.y*1.5,
            };
        }).then(function(data_points) {
    
        // Scene
        var scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        // Camera
        var width = window.innerWidth;
        var height = window.innerHeight;
        var fov = 40;
        var near = 1;
        var far = 200;
        var camera = new THREE.PerspectiveCamera(fov, width/height, near, far);
        camera.position.set( 0, 55, 35 );
        camera.up.set( 0, 0, 1 );

        // Rendererr
        var renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(width, height);
        document.body.appendChild(renderer.domElement);

        var controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.screenSpacePanning = false;
        controls.maxDistance = 150;
        controls.maxPolarAngle = Math.PI/2;
        controls.mouseButtons = {
            RIGHT: THREE.MOUSE.ROTATE,
            MIDDLE: THREE.MOUSE.DOLLY,
            LEFT: THREE.MOUSE.PAN
        }

        controls.update();

        // Event Listeners
        window.addEventListener('resize', () => {
            var width = window.innerWidth;
            var height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        })
        window.addEventListener('mousemove', onMouseMove, false);
        window.addEventListener('mouseleave', onMouseLeave, false);

        // Light
        var light = new THREE.DirectionalLight(0xffffff);
        light.position.set(10, 10, 10);
        scene.add(light);

        var light = new THREE.DirectionalLight(0xffffff);
        light.position.set(-10, -10, -10);
        scene.add(light);

        var light = new THREE.AmbientLight(0x222222);
        scene.add(light);
        
        // Knowledge Element Color
        // MAXIMUM of 8 categories :(
        let color_array = [
            "rgb(255,0,0)",
            "rgb(0,255,0)",
            "rgb(100,100,255)",
            "rgb(255,255,0)",
            "rgb(255,0,255)",
            "rgb(255,102,255)",
            "rgb(192,192,192)",
            "rgb(0,255,255)",
        ]
        // Lighten or darken colors
        const RGB_Linear_Shade=(p,c)=>{
            var i=parseInt,r=Math.round,[a,b,c,d]=c.split(","),P=p<0,t=P?0:255*p,P=P?1+p:1-p;
            return"rgb"+(d?"a(":"(")+r(i(a[3]=="a"?a.slice(5):a.slice(4))*P+t)+","+r(i(b)*P+t)+","+r(i(c)*P+t)+(d?","+d:")");
        }

        // Add datapoints to map
        var knowledgeMap = new THREE.Object3D();
        for (var i=0; i<data_points.length; i++) {
            let geometry = new THREE.CylinderBufferGeometry(data_points[i].radius/225, data_points[i].radius/225, 
                data_points[i].pct*10, 30, 30);            // Scale percentile from [0, 0.70] to prevent super dark colors
            geometry.translate( 0, 12.5, 0 );
            geometry.rotateX( Math.PI / 2 );

            var thisColor = RGB_Linear_Shade(-data_points[i].pct*0.70, color_array[data_points[i].label]);
            var material = new THREE.MeshLambertMaterial( {color: thisColor } );
            var cylinder = new THREE.Mesh( geometry, material );
            
            cylinder.userData.id = i;
            cylinder.position.set(data_points[i].x, data_points[i].y, (data_points[i].pct*10)/2 - 12.5);
            knowledgeMap.add(cylinder);
        }
        scene.add(knowledgeMap);

        var render = function() {
            requestAnimationFrame(render);
            controls.update();
            renderer.render(scene, camera);
        }
        render();
        
        // Hover interaction
        var mouseRay = new THREE.Vector3();
        var raycaster = new THREE.Raycaster();

        // mouseMove optimization (checks every 100-ms)
        var mouseMoveTimer = null;
        function onMouseMove(event) {
            if (mouseMoveTimer) {
                window.clearTimeout(mouseMoveTimer);
            }
            mouseMoveTimer = window.setTimeout(delayedMouseMove(event), 200);
        }
        function delayedMouseMove(event) {
            mouseRay.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
            mouseRay.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
            mouseRay.z = 1;
            let mouse = [event.clientX, event.clientY];
            raycaster.setFromCamera(mouseRay, camera);
            let intersects = raycaster.intersectObjects(scene.children, true);
            if (intersects[0]) {
                let sorted_intersects = sortIntersectsByDistanceToRay(intersects);
                let intersect = sorted_intersects[0];
                let index = intersect.object.userData.id;
                let datum = data_points[index];
                if (datum) {
                    highlightPoint(datum);
                    showTooltip(mouse, datum)
                }
            } else {
                removeHighlights();
                hideTooltip();
            }
        }
        function sortIntersectsByDistanceToRay(intersects) {
            return _.sortBy(intersects, "distanceToRay");
        }


        // Mouse hover interaction
        hoverContainer = new THREE.Object3D();
        scene.add(hoverContainer);
        function highlightPoint(datum) {
            removeHighlights()
            let geometry = new THREE.CylinderBufferGeometry(datum.radius/175, datum.radius/175, 
                datum.pct*10+0.01, 30, 30);            
            geometry.translate( 0, 12.5, 0 );
            geometry.rotateX( Math.PI / 2 );
            var material = new THREE.MeshLambertMaterial( {color: color_array[datum.label] } );
           
            var cylinder = new THREE.Mesh( geometry, material );
            cylinder.userData.id = i;
            cylinder.position.set(datum.x, datum.y, (datum.pct*10)/2 - 12.5);
            knowledgeMap.add(cylinder);

            hoverContainer.add(cylinder);
        }
        function removeHighlights() {
            hoverContainer.remove(...hoverContainer.children);
        }
        function onMouseLeave() {
            removeHighlights()
        }


        // Initial tooltip state
        let tooltip_state = { display: "none" }
        let tooltip_template = document.createRange().createContextualFragment(`<div id="tooltip" style="border: 1px solid #000000; display: none; position: absolute; pointer-events: none; font-family: Raleway, Arial, Helvetica, sans-serif; font-size: 13px; width: 120px; text-align: center; line-height: 1; padding: 6px; background: white;">
        <div id="point_tip" style="padding: 4px; margin-bottom: 4px;"></div>
        <div id="group_tip" style="padding: 4px;"></div>
        </div>`);
        document.body.append(tooltip_template);

        let $tooltip = document.querySelector('#tooltip');
        let $point_tip = document.querySelector('#point_tip');
        let $group_tip = document.querySelector('#group_tip');

        function updateTooltip() {
            $tooltip.style.display = tooltip_state.display;
            $tooltip.style.left = tooltip_state.left + 'px';
            $tooltip.style.top = tooltip_state.top + 'px';
            $point_tip.innerText = tooltip_state.name;
            $point_tip.style.background = color_array[tooltip_state.label];
            $group_tip.innerText = `DataShape ${tooltip_state.description}
                \nInfluence Distance: ${tooltip_state.radius}
                \nFrequency: ${Math.round(tooltip_state.pct*100)}`;
        }
        function showTooltip(mouse, datum) {
            let tooltip_width = 120;
            let x_offset = -tooltip_width / 2;
            let y_offset = 30;
            tooltip_state.display = "block";
            tooltip_state.left = mouse[0] + x_offset;
            tooltip_state.top = mouse[1] + y_offset;
            tooltip_state.name = datum.name;
            tooltip_state.label = datum.label;
            tooltip_state.description = datum.description;
            tooltip_state.radius = datum.radius;
            tooltip_state.pct = datum.pct;
            updateTooltip();
        }
        function hideTooltip() {
            tooltip_state.display = "none";
            updateTooltip();
        }
            
        //End d3.csv
        })
    </script>
</body>    
</html>