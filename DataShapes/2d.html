<!DOCTYPE html>
<html>

<head>
    <!-- Dependencies : three.js, lodash.js, d3.js -->
    <script src="three.min.js"></script>
    <script src="https://d3js.org/d3.v5.min.js" charset="utf-8"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.19/lodash.min.js"></script>
    <link rel="stylesheet" href="title.css" type="text/css">

<body>
    <div id="info">2D Knowledge Map</div>
    <script>
        // Load in data (asynchronously)
        d3.csv("mnist2D.csv", function (data) {
            return {
                x: +data.x*80,
                y: +data.y*50,
                name: data.name,
                label: +data.label,
                radius: +data.radius*10,
                frequency: +data.frequency
            };
        }).then(function(data_points) {

        let width = window.innerWidth;
        let viz_width = width;
        let height = window.innerHeight;

        let fov = 40;
        let near = 10;
        let far = 7000;

        // Set up camera and scene
        let camera = new THREE.PerspectiveCamera(
            fov,
            width / height,
            near,
            far
        );

        let scene = new THREE.Scene();

        window.addEventListener('resize', () => {
            width = window.innerWidth;
            viz_width = width;
            height = window.innerHeight;

            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        })
        window.addEventListener('mousemove', onMouseMove, false);
        window.addEventListener('mouseleave', onMouseLeave, false);

        let color_array = [
            "#1f78b4",
            "#b2df8a",
            "#33a02c",
            "#fb9a99",
            "#e31a1c",
            "#fdbf6f",
            "#ff7f00",
            "#6a3d9a",
            "#cab2d6",
            "#ffff99",
            "#d3d3d3"
        ]

        // Add canvas
        let renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        document.body.appendChild(renderer.domElement);

        circle_sprite = new THREE.TextureLoader().load(
            "https://fastforwardlabs.github.io/visualization_assets/circle-sprite.png"
        )

        let zoom = d3.zoom()
            .scaleExtent([getScaleFromZ(far), getScaleFromZ(near)])
            .on('zoom', () => {
                let d3_transform = d3.event.transform;
                zoomHandler(d3_transform);
        });

        view = d3.select(renderer.domElement);
        function setUpZoom() {
            view.call(zoom);
            let initial_scale = getScaleFromZ(far);
            var initial_transform = d3.zoomIdentity.translate(viz_width / 2, height / 2).scale(initial_scale);
            zoom.transform(view, initial_transform);
            camera.position.set(0, 0, far);
        }
        setUpZoom();

        // Create circle geometries
        for (var i=0; i<data_points.length; i++) {
            // Circle
            let geo = new THREE.CircleBufferGeometry(data_points[i].radius, 32);
            let mat = new THREE.MeshBasicMaterial( {color: color_array[data_points[i].label] } );
            let mesh = new THREE.Mesh(geo, mat);
            mesh.userData.id = i;
            // Outline
            let geo2 = geo.clone();
            // strip the center point from CircleBufferGeometry:
            geo2.attributes.position.array = geo.attributes.position.array.slice(3);
            geo2.attributes.position.count--;
            geo2.attributes.normal.array = geo.attributes.position.array.slice(3);
            geo2.attributes.normal.count--;
            geo2.deleteAttribute("uv"); // lines don't need UVs
            geo2.index = null; // don't need indexing for this kind of line
            let mat2 = new THREE.LineBasicMaterial({ color: 0x000000 });
            let line = new THREE.LineLoop(geo2, mat2);
            // data point
            let group = new THREE.Group();
            group.add(mesh);
            group.add(line);
            group.position.set(data_points[i].x, data_points[i].y, data_points[i].frequency*2);
            scene.add(group);
        }

        scene.background = new THREE.Color(0xffffff);

        // Three.js render loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Zoom and scale
        function zoomHandler(d3_transform) {
            let scale = d3_transform.k;
            let x = -(d3_transform.x - viz_width / 2) / scale;
            let y = (d3_transform.y - height / 2) / scale;
            let z = getZFromScale(scale);
            camera.position.set(x, y, z);
        }
        function getScaleFromZ(camera_z_position) {
            let half_fov = fov / 2;
            let half_fov_radians = toRadians(half_fov);
            let half_fov_height = Math.tan(half_fov_radians) * camera_z_position;
            let fov_height = half_fov_height * 2;
            let scale = height / fov_height; // Divide visualization height by height derived from field of view
            return scale;
        }
        function getZFromScale(scale) {
            let half_fov = fov / 2;
            let half_fov_radians = toRadians(half_fov);
            let scale_height = height / scale;
            let camera_z_position = scale_height / (2 * Math.tan(half_fov_radians));
            return camera_z_position;
        }

        function toRadians(angle) {
            return angle * (Math.PI / 180);
        }

        // Hover and tooltip interaction
        var mouseRay = new THREE.Vector3();
        var raycaster = new THREE.Raycaster();

        function onMouseMove(event) {
            mouseRay.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
            mouseRay.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
            mouseRay.z = 1;
            let mouse = [event.clientX, event.clientY];
            raycaster.setFromCamera(mouseRay, camera);
            let intersects = raycaster.intersectObjects(scene.children, true);
            if (intersects[0]) {
                let sorted_intersects = sortIntersectsByDistanceToRay(intersects);
                let intersect = sorted_intersects[0];
                let index = intersect.object.userData.id;
                let datum = data_points[index];
                highlightPoint(datum);
                showTooltip(mouse, datum);
            } else {
                removeHighlights();
                hideTooltip();
            }
        }

        function sortIntersectsByDistanceToRay(intersects) {
            return _.sortBy(intersects, "distanceToRay");
        }

        hoverContainer = new THREE.Object3D();
        scene.add(hoverContainer);

        function highlightPoint(datum) {          
            let geo = new THREE.CircleBufferGeometry(datum.radius*2, 40);
            let mat = new THREE.MeshBasicMaterial( { color: color_array[datum.label] } );
            let mesh = new THREE.Mesh(geo, mat);
            // Outline
            let geo2 = geo.clone();
            // strip the center point from CircleBufferGeometry:
            geo2.attributes.position.array = geo.attributes.position.array.slice(3);
            geo2.attributes.position.count--;
            geo2.attributes.normal.array = geo.attributes.position.array.slice(3);
            geo2.attributes.normal.count--;
            geo2.deleteAttribute("uv"); // lines don't need UVs
            geo2.index = null; // don't need indexing for this kind of line
            let mat2 = new THREE.LineBasicMaterial({ color: 0x000000 });
            let line = new THREE.LineLoop(geo2, mat2);
            // data point
            let group = new THREE.Group();
            group.add(mesh);
            group.add(line);
            group.position.set(datum.x, datum.y, 10000);
            hoverContainer.add(group);
        }

        function removeHighlights() {
            hoverContainer.remove(...hoverContainer.children);
        }

        function onMouseLeave() {
            removeHighlights()
        }

        // Initial tooltip state
        let tooltip_state = { display: "none" }

        let tooltip_template = document.createRange().createContextualFragment(`<div id="tooltip" style="border: 1px solid #000000; display: none; position: absolute; pointer-events: none; font-family: Raleway, Arial, Helvetica, sans-serif; font-size: 13px; width: 120px; text-align: center; line-height: 1; padding: 6px; background: white;">
        <div id="point_tip" style="padding: 4px; margin-bottom: 4px;"></div>
        <div id="group_tip" style="padding: 4px;"></div>
        </div>`);
        document.body.append(tooltip_template);

        let $tooltip = document.querySelector('#tooltip');
        let $point_tip = document.querySelector('#point_tip');
        let $group_tip = document.querySelector('#group_tip');

        function updateTooltip() {
            $tooltip.style.display = tooltip_state.display;
            $tooltip.style.left = tooltip_state.left + 'px';
            $tooltip.style.top = tooltip_state.top + 'px';
            $point_tip.innerText = tooltip_state.name;
            $point_tip.style.background = color_array[tooltip_state.label];
            $group_tip.innerText = `DataShape ${tooltip_state.label}
                \nRadius: ${tooltip_state.radius}
                \nFrequency: ${tooltip_state.frequency}
                \nMetadata: 16f2f5de1f53dcf0a\n8e0a74c532a32a\n65e61686fa5d96\n92a9317e8971bb35`;
        }
        function showTooltip(mouse, datum) {
            let tooltip_width = 120;
            let x_offset = -tooltip_width / 2;
            let y_offset = 30;
            tooltip_state.display = "block";
            tooltip_state.left = mouse[0] + x_offset;
            tooltip_state.top = mouse[1] + y_offset;
            tooltip_state.name = datum.name;
            tooltip_state.label = datum.label;
            tooltip_state.radius = datum.radius;
            tooltip_state.frequency = datum.frequency;
            updateTooltip();
        }
        function hideTooltip() {
            tooltip_state.display = "none";
            updateTooltip();
        }

        })
    </script>
</body>