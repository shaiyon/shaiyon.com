<!DOCTYPE html>
<html>

<head>
    <!-- Dependencies : three.js, lodash.js, d3.js -->
    <script src="three.min.js"></script>
    <script src="https://d3js.org/d3.v5.min.js" charset="utf-8"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.5/lodash.js"></script>
    <link rel="stylesheet" href="/styles.css" type="text/css" media="screen">

<body>
    <div id="info">2D Knowledge Map</div>
    <script>
        // Load in data (asynchronously)
        d3.csv("mnist2D.csv", function (data) {
            return {
                x: +data.x*100,
                y: +data.y*60,
                name: data.name,
                label: +data.label,
                radius: +data.radius,
                frequency: +data.frequency
            };
        }).then(function(data_points) {

        let width = window.innerWidth;
        let viz_width = width;
        let height = window.innerHeight;

        let fov = 40;
        let near = 10;
        let far = 7000;

        // Set up camera and scene
        let camera = new THREE.PerspectiveCamera(
            fov,
            width / height,
            near,
            far
        );

        window.addEventListener('resize', () => {
            width = window.innerWidth;
            viz_width = width;
            height = window.innerHeight;

            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        })

        let color_array = [
            "#1f78b4",
            "#b2df8a",
            "#33a02c",
            "#fb9a99",
            "#e31a1c",
            "#fdbf6f",
            "#ff7f00",
            "#6a3d9a",
            "#cab2d6",
            "#ffff99",
            "#d3d3d3"
        ]

        // Add canvas
        let renderer = new THREE.WebGLRenderer();
        renderer.setSize(width, height);
        document.body.appendChild(renderer.domElement);

        circle_sprite = new THREE.TextureLoader().load(
            "https://fastforwardlabs.github.io/visualization_assets/circle-sprite.png"
        )

        let zoom = d3.zoom()
            .scaleExtent([getScaleFromZ(far), getScaleFromZ(near)])
            .on('zoom', () => {
                let d3_transform = d3.event.transform;
                zoomHandler(d3_transform);
        });

        view = d3.select(renderer.domElement);
        function setUpZoom() {
            view.call(zoom);
            let initial_scale = getScaleFromZ(far);
            var initial_transform = d3.zoomIdentity.translate(viz_width / 2, height / 2).scale(initial_scale);
            zoom.transform(view, initial_transform);
            camera.position.set(0, 0, far);
        }
        setUpZoom();

        var coordinates = new Float32Array(data_points.length*3);
        var colors = new Float32Array(data_points.length*3);
        var sizes = new Float32Array(data_points.length);

        for (var i=0; i<data_points.length; i++) {
            // Set vector coordinates from data
            let vertex = new THREE.Vector3(data_points[i].x, data_points[i].y, 0);
            let color = new THREE.Color(color_array[data_points[i].label]);
            vertex.toArray(coordinates, i*3);
            color.toArray(colors, i*3);
            sizes[i] = data_points[i].radius*100;
        }

        let geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(coordinates, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
		geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1 ));


        let pointsMaterial = new THREE.PointsMaterial({
            sizeAttenuation: true,
            vertexColors: THREE.VertexColors,
            map: circle_sprite,
            transparent: true
        });

        let points = new THREE.Points(geometry, pointsMaterial);

        let scene = new THREE.Scene();
        scene.add(points);
        scene.background = new THREE.Color(0xefefef);


        // Three.js render loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Zoom and scale
        function zoomHandler(d3_transform) {
            let scale = d3_transform.k;
            let x = -(d3_transform.x - viz_width / 2) / scale;
            let y = (d3_transform.y - height / 2) / scale;
            let z = getZFromScale(scale);
            camera.position.set(x, y, z);
        }
        function getScaleFromZ(camera_z_position) {
            let half_fov = fov / 2;
            let half_fov_radians = toRadians(half_fov);
            let half_fov_height = Math.tan(half_fov_radians) * camera_z_position;
            let fov_height = half_fov_height * 2;
            let scale = height / fov_height; // Divide visualization height by height derived from field of view
            return scale;
        }
        function getZFromScale(scale) {
            let half_fov = fov / 2;
            let half_fov_radians = toRadians(half_fov);
            let scale_height = height / scale;
            let camera_z_position = scale_height / (2 * Math.tan(half_fov_radians));
            return camera_z_position;
        }

        function toRadians(angle) {
            return angle * (Math.PI / 180);
        }

        // Hover and tooltip interaction

        raycaster = new THREE.Raycaster();
        raycaster.params.Points.threshold = 50;

        view.on("mousemove", () => {
            let [mouseX, mouseY] = d3.mouse(view.node());
            let mouse_position = [mouseX, mouseY];
            checkIntersects(mouse_position);
        });
        function mouseToThree(mouseX, mouseY) {
            return new THREE.Vector3(
                mouseX / viz_width * 2 - 1,
                -(mouseY / height) * 2 + 1,
                1
            );
        }
        function checkIntersects(mouse_position) {
            let mouse_vector = mouseToThree(...mouse_position);
            raycaster.setFromCamera(mouse_vector, camera);
            let intersects = raycaster.intersectObject(points);
            if (intersects[0]) {
                let sorted_intersects = sortIntersectsByDistanceToRay(intersects);
                let intersect = sorted_intersects[0];
                let index = intersect.index;
                let datum = data_points[index];
                highlightPoint(datum);
                showTooltip(mouse_position, datum);
            } else {
                removeHighlights();
                hideTooltip();
            }
        }
        function sortIntersectsByDistanceToRay(intersects) {
            return _.sortBy(intersects, "distanceToRay");
        }

        hoverContainer = new THREE.Object3D()
        scene.add(hoverContainer);

        function highlightPoint(datum) {
            removeHighlights();
            let geometry = new THREE.Geometry();
            geometry.vertices.push(
                new THREE.Vector3(
                    datum.x,
                    datum.y,
                    0
                )
            );
            geometry.colors = [new THREE.Color(color_array[datum.label])];
            let material = new THREE.PointsMaterial({
                size: datum.radius*120,
                sizeAttenuation: true,
                vertexColors: THREE.VertexColors,
                map: circle_sprite,
                transparent: true
            });

            let point = new THREE.Points(geometry, material);
            hoverContainer.add(point);
        }

        function removeHighlights() {
            hoverContainer.remove(...hoverContainer.children);
        }

        view.on("mouseleave", () => {
            removeHighlights()
        });

        // Initial tooltip state
        let tooltip_state = { display: "none" }

        let tooltip_template = document.createRange().createContextualFragment(`<div id="tooltip" style="display: none; position: absolute; pointer-events: none; font-size: 13px; width: 120px; text-align: center; line-height: 1; padding: 6px; background: white; font-family: sans-serif;">
        <div id="point_tip" style="padding: 4px; margin-bottom: 4px;"></div>
        <div id="group_tip" style="padding: 4px;"></div>
        </div>`);
        document.body.append(tooltip_template);

        let $tooltip = document.querySelector('#tooltip');
        let $point_tip = document.querySelector('#point_tip');
        let $group_tip = document.querySelector('#group_tip');

        function updateTooltip() {
            $tooltip.style.display = tooltip_state.display;
            $tooltip.style.left = tooltip_state.left + 'px';
            $tooltip.style.top = tooltip_state.top + 'px';
            $point_tip.innerText = tooltip_state.name;
            $point_tip.style.background = color_array[tooltip_state.label];
            $group_tip.innerText = `DataShape ${tooltip_state.label}
                \nRadius: ${tooltip_state.radius}
                \nFrequency: ${tooltip_state.frequency}`;
        }
        function showTooltip(mouse_position, datum) {
            let tooltip_width = 120;
            let x_offset = -tooltip_width / 2;
            let y_offset = 30;
            tooltip_state.display = "block";
            tooltip_state.left = mouse_position[0] + x_offset;
            tooltip_state.top = mouse_position[1] + y_offset;
            tooltip_state.name = datum.name;
            tooltip_state.label = datum.label;
            tooltip_state.radius = datum.radius;
            tooltip_state.frequency = datum.frequency;
            updateTooltip();
        }
        function hideTooltip() {
            tooltip_state.display = "none";
            updateTooltip();
        }

        })
    </script>
</body>